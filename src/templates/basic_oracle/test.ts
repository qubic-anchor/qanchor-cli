// {{project_name}} Integration Tests
// Generated by QAnchor

import { describe, it, expect, beforeAll, afterAll } from '@jest/globals';
import { Connection, PublicKey } from '@qubic/web3.js';
import { {{project_name_pascal}}OracleClient } from '../generated/typescript/client';

describe('{{project_name_pascal}}Oracle Integration Tests', () => {
  let connection: Connection;
  let client: {{project_name_pascal}}OracleClient;
  let authority: PublicKey;
  let oracle: PublicKey;

  beforeAll(async () => {
    // Connect to local Qubic network
    connection = new Connection('http://localhost:8080');
    
    // Generate test keypairs
    authority = PublicKey.generate();
    oracle = PublicKey.generate();
    
    // Initialize the Oracle client
    client = new {{project_name_pascal}}OracleClient(connection, oracle);
  });

  afterAll(async () => {
    // Cleanup if needed
  });

  describe('Oracle Initialization', () => {
    it('should initialize oracle with authority', async () => {
      const result = await client.initialize(authority);
      expect(result.success).toBe(true);
      
      const oracleState = await client.getOracleState();
      expect(oracleState.authority).toEqual(authority);
      expect(oracleState.prices).toEqual({});
      expect(oracleState.lastUpdated).toBe(0);
    });
  });

  describe('Price Updates', () => {
    it('should update BTC price successfully', async () => {
      const assetId = 'BTC';
      const price = 50000;
      const timestamp = Math.floor(Date.now() / 1000);

      const result = await client.updatePrice(assetId, price, timestamp);
      expect(result.success).toBe(true);

      const priceData = await client.getPrice(assetId);
      expect(priceData).toBeDefined();
      expect(priceData.value).toBe(price);
      expect(priceData.timestamp).toBe(timestamp);
      expect(priceData.confidence).toBe(95); // Default confidence
    });

    it('should update multiple asset prices', async () => {
      const assets = [
        { id: 'ETH', price: 3000, timestamp: Math.floor(Date.now() / 1000) },
        { id: 'ADA', price: 100, timestamp: Math.floor(Date.now() / 1000) + 1 },
        { id: 'SOL', price: 150, timestamp: Math.floor(Date.now() / 1000) + 2 },
      ];

      for (const asset of assets) {
        const result = await client.updatePrice(asset.id, asset.price, asset.timestamp);
        expect(result.success).toBe(true);
      }

      // Verify all prices
      for (const asset of assets) {
        const priceData = await client.getPrice(asset.id);
        expect(priceData.value).toBe(asset.price);
        expect(priceData.timestamp).toBe(asset.timestamp);
      }
    });

    it('should reject outdated timestamps', async () => {
      const oldTimestamp = Math.floor(Date.now() / 1000) - 3600; // 1 hour ago
      
      await expect(
        client.updatePrice('BTC', 51000, oldTimestamp)
      ).rejects.toThrow('InvalidTimestamp');
    });
  });

  describe('Price Retrieval', () => {
    it('should return undefined for non-existent assets', async () => {
      const priceData = await client.getPrice('NONEXISTENT');
      expect(priceData).toBeUndefined();
    });

    it('should retrieve latest price for existing assets', async () => {
      const assetId = 'BTC';
      const latestPrice = 52000;
      const latestTimestamp = Math.floor(Date.now() / 1000);

      await client.updatePrice(assetId, latestPrice, latestTimestamp);
      
      const priceData = await client.getPrice(assetId);
      expect(priceData.value).toBe(latestPrice);
      expect(priceData.timestamp).toBe(latestTimestamp);
    });
  });

  describe('Error Handling', () => {
    it('should handle invalid asset IDs', async () => {
      await expect(
        client.updatePrice('', 1000, Math.floor(Date.now() / 1000))
      ).rejects.toThrow();
    });

    it('should handle unauthorized updates', async () => {
      const unauthorizedAuthority = PublicKey.generate();
      const unauthorizedClient = new {{project_name_pascal}}OracleClient(
        connection, 
        oracle,
        unauthorizedAuthority
      );

      await expect(
        unauthorizedClient.updatePrice('BTC', 1000, Math.floor(Date.now() / 1000))
      ).rejects.toThrow('Unauthorized');
    });
  });

  describe('Events', () => {
    it('should emit PriceUpdated event on price updates', async () => {
      const assetId = 'ETH';
      const oldPrice = 3000;
      const newPrice = 3100;
      const timestamp = Math.floor(Date.now() / 1000);

      // First update to establish old price
      await client.updatePrice(assetId, oldPrice, timestamp);
      
      // Listen for events
      const events: any[] = [];
      client.onPriceUpdated((event) => {
        events.push(event);
      });

      // Update price and check event
      await client.updatePrice(assetId, newPrice, timestamp + 1);
      
      expect(events).toHaveLength(1);
      expect(events[0].assetId).toBe(assetId);
      expect(events[0].oldPrice).toBe(oldPrice);
      expect(events[0].newPrice).toBe(newPrice);
    });
  });
});

