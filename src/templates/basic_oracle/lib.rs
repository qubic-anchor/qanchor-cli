// {{project_name}} - Basic Oracle Contract
// Generated by QAnchor

use qubic_sdk::prelude::*;

#[derive(Debug, Clone)]
pub struct {{project_name_pascal}}Oracle {
    pub authority: PublicKey,
    pub prices: std::collections::HashMap<String, PriceData>,
    pub last_updated: u64,
}

#[derive(Debug, Clone)]
pub struct PriceData {
    pub value: u64,
    pub timestamp: u64,
    pub confidence: u8,
}

impl {{project_name_pascal}}Oracle {
    pub fn new(authority: PublicKey) -> Self {
        Self {
            authority,
            prices: std::collections::HashMap::new(),
            last_updated: 0,
        }
    }
    
    pub fn update_price(&mut self, asset_id: String, price: u64, timestamp: u64) -> Result<(), OracleError> {
        if timestamp <= self.last_updated {
            return Err(OracleError::InvalidTimestamp);
        }
        
        let price_data = PriceData {
            value: price,
            timestamp,
            confidence: 95, // Default confidence
        };
        
        self.prices.insert(asset_id, price_data);
        self.last_updated = timestamp;
        
        Ok(())
    }
    
    pub fn get_price(&self, asset_id: &str) -> Option<&PriceData> {
        self.prices.get(asset_id)
    }
}

#[derive(Debug)]
pub enum OracleError {
    InvalidTimestamp,
    AssetNotFound,
    Unauthorized,
}

// QAnchor contract entry points
#[no_mangle]
pub extern "C" fn initialize(authority: PublicKey) -> {{project_name_pascal}}Oracle {
    {{project_name_pascal}}Oracle::new(authority)
}

#[no_mangle]
pub extern "C" fn update_price(
    oracle: &mut {{project_name_pascal}}Oracle,
    asset_id: String,
    price: u64,
    timestamp: u64,
) -> Result<(), OracleError> {
    oracle.update_price(asset_id, price, timestamp)
}

#[no_mangle]
pub extern "C" fn get_price(
    oracle: &{{project_name_pascal}}Oracle,
    asset_id: String,
) -> Option<PriceData> {
    oracle.get_price(&asset_id).cloned()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_oracle_creation() {
        let authority = PublicKey::default();
        let oracle = {{project_name_pascal}}Oracle::new(authority);
        assert_eq!(oracle.authority, authority);
        assert!(oracle.prices.is_empty());
    }
    
    #[test]
    fn test_price_update() {
        let authority = PublicKey::default();
        let mut oracle = {{project_name_pascal}}Oracle::new(authority);
        
        let result = oracle.update_price("BTC".to_string(), 50000, 1640995200);
        assert!(result.is_ok());
        
        let price = oracle.get_price("BTC");
        assert!(price.is_some());
        assert_eq!(price.unwrap().value, 50000);
    }
}

